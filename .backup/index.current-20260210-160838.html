<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Signal Interference Showcase</title>
    <style>
      :root {
        --ink: #d8e6ff;
        --ink-dim: rgba(206, 222, 255, 0.68);
        --edge: rgba(160, 196, 255, 0.34);
        --surface: rgba(7, 14, 29, 0.52);
        --surface-strong: rgba(10, 18, 38, 0.76);
        --accent: #97c7ff;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #050913;
        color: var(--ink);
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      }

      #webglCanvas,
      #networkCanvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      #webglCanvas {
        z-index: 0;
      }

      #networkCanvas {
        z-index: 1;
        pointer-events: none;
        mix-blend-mode: screen;
        opacity: 0.45;
      }

      .screen-vignette {
        position: fixed;
        inset: 0;
        z-index: 2;
        pointer-events: none;
        background:
          radial-gradient(circle at 50% 42%, rgba(91, 145, 220, 0.18), transparent 46%),
          radial-gradient(circle at 50% 50%, transparent 48%, rgba(2, 7, 16, 0.72) 100%);
      }

      .overlay {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
        display: grid;
        grid-template-rows: auto 1fr auto;
      }

      .title-block {
        margin: clamp(16px, 3vw, 28px) auto 0;
        width: min(1220px, calc(100% - 32px));
        display: flex;
        justify-content: space-between;
        gap: 24px;
        align-items: flex-start;
      }

      .title-left .kicker {
        margin: 0 0 8px;
        font-size: 11px;
        letter-spacing: 0.24em;
        text-transform: uppercase;
        color: rgba(202, 224, 255, 0.74);
      }

      .title-left h1 {
        margin: 0;
        font-size: clamp(20px, 3.2vw, 42px);
        letter-spacing: 0.04em;
        font-weight: 640;
        text-transform: uppercase;
        color: rgba(228, 239, 255, 0.95);
      }

      .title-left p {
        margin: 10px 0 0;
        max-width: 52ch;
        color: rgba(200, 218, 245, 0.74);
        font-size: clamp(12px, 1.6vw, 14px);
        line-height: 1.56;
      }

      .status-pill {
        margin-top: 2px;
        border: 1px solid var(--edge);
        background: linear-gradient(145deg, rgba(19, 35, 68, 0.7), rgba(8, 15, 30, 0.72));
        color: rgba(219, 234, 255, 0.88);
        border-radius: 999px;
        min-height: 34px;
        padding: 0 14px;
        display: inline-flex;
        align-items: center;
        gap: 9px;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: #8bc0ff;
        box-shadow: 0 0 0 6px rgba(139, 192, 255, 0.14);
      }

      .focus-shell {
        align-self: center;
        justify-self: center;
        width: min(1220px, calc(100% - 28px));
        display: grid;
        grid-template-columns: minmax(140px, 180px) 1fr minmax(140px, 180px);
        align-items: center;
        gap: clamp(10px, 2vw, 24px);
      }

      .focus-frame {
        position: relative;
        height: min(66vh, 560px);
        border: 1px solid rgba(168, 202, 255, 0.46);
        background:
          linear-gradient(180deg, rgba(9, 18, 36, 0.2), rgba(8, 14, 26, 0.42)),
          radial-gradient(circle at 50% 50%, rgba(98, 149, 224, 0.1), transparent 62%);
        box-shadow:
          0 0 0 1px rgba(163, 197, 255, 0.2) inset,
          0 24px 64px rgba(3, 8, 16, 0.44),
          0 0 60px rgba(99, 151, 227, 0.15);
        overflow: hidden;
      }

      .focus-frame::before,
      .focus-frame::after {
        content: "";
        position: absolute;
        inset: 16px;
        border: 1px solid rgba(160, 193, 245, 0.22);
        pointer-events: none;
      }

      .focus-frame::after {
        inset: 48px;
        border-color: rgba(153, 190, 245, 0.12);
      }

      .frame-corner {
        position: absolute;
        width: 36px;
        height: 36px;
        border-color: rgba(198, 221, 255, 0.58);
        border-style: solid;
        pointer-events: none;
        opacity: 0.84;
      }

      .corner-tl {
        top: 12px;
        left: 12px;
        border-width: 2px 0 0 2px;
      }

      .corner-tr {
        top: 12px;
        right: 12px;
        border-width: 2px 2px 0 0;
      }

      .corner-bl {
        bottom: 12px;
        left: 12px;
        border-width: 0 0 2px 2px;
      }

      .corner-br {
        bottom: 12px;
        right: 12px;
        border-width: 0 2px 2px 0;
      }

      .focus-label {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 10px;
        border-radius: 999px;
        border: 1px solid rgba(178, 209, 255, 0.34);
        background: rgba(9, 18, 37, 0.72);
        font-size: 10px;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: rgba(218, 233, 255, 0.9);
      }

      .focus-hint {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        font-size: 11px;
        letter-spacing: 0.08em;
        color: rgba(198, 217, 248, 0.74);
        text-transform: uppercase;
      }

      .probe {
        border: 1px solid var(--edge);
        background: linear-gradient(160deg, rgba(11, 23, 46, 0.72), rgba(7, 13, 25, 0.74));
        box-shadow: 0 18px 30px rgba(2, 5, 10, 0.44);
        min-height: 180px;
        border-radius: 10px;
        padding: 11px 10px 10px;
        display: grid;
        gap: 10px;
      }

      .probe-title {
        margin: 0;
        font-size: 10px;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        color: rgba(203, 223, 255, 0.86);
      }

      .probe-row {
        display: grid;
        gap: 5px;
      }

      .probe-row-head {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        color: rgba(184, 204, 239, 0.86);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.11em;
      }

      .probe-bar {
        width: 100%;
        height: 5px;
        background: rgba(137, 171, 227, 0.18);
        border-radius: 999px;
        overflow: hidden;
      }

      .probe-fill {
        width: 0%;
        height: 100%;
        border-radius: inherit;
        background: linear-gradient(90deg, #79aef7, #bfd9ff);
        box-shadow: 0 0 16px rgba(121, 174, 247, 0.45);
      }

      .footer-note {
        justify-self: center;
        margin-bottom: clamp(8px, 2vh, 14px);
        border: 1px solid rgba(163, 195, 248, 0.28);
        background: rgba(7, 14, 28, 0.65);
        color: rgba(196, 215, 245, 0.78);
        border-radius: 999px;
        min-height: 30px;
        padding: 0 12px;
        display: inline-flex;
        align-items: center;
        font-size: 11px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .warning {
        position: fixed;
        left: 50%;
        bottom: 20px;
        transform: translateX(-50%);
        z-index: 6;
        pointer-events: none;
        color: #ffc6c6;
        border: 1px solid rgba(255, 168, 168, 0.5);
        background: rgba(46, 11, 17, 0.76);
        border-radius: 10px;
        padding: 8px 12px;
        font-size: 12px;
        display: none;
      }

      @media (max-width: 960px) {
        .focus-shell {
          grid-template-columns: 1fr;
          gap: 10px;
        }

        .focus-frame {
          height: min(58vh, 420px);
        }

        .probe {
          min-height: auto;
          grid-template-columns: repeat(2, minmax(0, 1fr));
          align-items: start;
        }

        .probe-title {
          grid-column: 1 / -1;
        }

        .title-block {
          display: grid;
          gap: 10px;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="webglCanvas" aria-hidden="true"></canvas>
    <canvas id="networkCanvas" aria-hidden="true"></canvas>
    <div class="screen-vignette" aria-hidden="true"></div>

    <main class="overlay">
      <header class="title-block">
        <div class="title-left">
          <p class="kicker">Signal Interference / WebGL Demo</p>
          <h1>Cold Codec Drift</h1>
          <p>
            Procedural distortion inspired by digital interference and compression failure.
            The image stays readable while micro-glitches and signal slices pulse briefly.
          </p>
        </div>
        <div class="status-pill"><span class="status-dot"></span><span id="statusText">Stable Signal</span></div>
      </header>

      <section class="focus-shell" aria-label="signal showcase frame">
        <aside class="probe">
          <h2 class="probe-title">Probe A / Distortion Bus</h2>
          <div class="probe-row">
            <div class="probe-row-head"><span>Distortion</span><strong id="metricDistortion">0.00</strong></div>
            <div class="probe-bar"><div class="probe-fill" id="barDistortion"></div></div>
          </div>
          <div class="probe-row">
            <div class="probe-row-head"><span>RGB Shift</span><strong id="metricRgb">0.00</strong></div>
            <div class="probe-bar"><div class="probe-fill" id="barRgb"></div></div>
          </div>
          <div class="probe-row">
            <div class="probe-row-head"><span>Signal Speed</span><strong id="metricSpeed">0.00</strong></div>
            <div class="probe-bar"><div class="probe-fill" id="barSpeed"></div></div>
          </div>
        </aside>

        <div class="focus-frame" id="focusFrame">
          <span class="frame-corner corner-tl"></span>
          <span class="frame-corner corner-tr"></span>
          <span class="frame-corner corner-bl"></span>
          <span class="frame-corner corner-br"></span>
          <div class="focus-label">Line Signal Viewport</div>
          <div class="focus-hint">Move pointer gently to modulate interference</div>
        </div>

        <aside class="probe">
          <h2 class="probe-title">Probe B / Codec Noise</h2>
          <div class="probe-row">
            <div class="probe-row-head"><span>Glitch Amount</span><strong id="metricGlitch">0.00</strong></div>
            <div class="probe-bar"><div class="probe-fill" id="barGlitch"></div></div>
          </div>
          <div class="probe-row">
            <div class="probe-row-head"><span>Slice Strength</span><strong id="metricSlice">0.00</strong></div>
            <div class="probe-bar"><div class="probe-fill" id="barSlice"></div></div>
          </div>
          <div class="probe-row">
            <div class="probe-row-head"><span>Micro Burst</span><strong id="metricMicro">0</strong></div>
            <div class="probe-bar"><div class="probe-fill" id="barMicro"></div></div>
          </div>
        </aside>
      </section>

      <div class="footer-note">Cinematic and restrained - no excessive strobing</div>
    </main>

    <div class="warning" id="warningBox">Texture load failed. Check image path and local server.</div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
      import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm";

      const IMAGE_URL =
        "./assets/c__Users_elecp_AppData_Roaming_Cursor_User_workspaceStorage_af789c37a1e700e62a26ba64abc1658a_images_image-a482a381-da7f-42a9-8594-f5f7e9cd55cc.png";
      const FALLBACK_URL = "./ImageReference/1.jpg";

      const webglCanvas = document.getElementById("webglCanvas");
      const networkCanvas = document.getElementById("networkCanvas");
      const warningBox = document.getElementById("warningBox");
      const statusText = document.getElementById("statusText");
      const focusFrame = document.getElementById("focusFrame");

      const metricDistortion = document.getElementById("metricDistortion");
      const metricGlitch = document.getElementById("metricGlitch");
      const metricRgb = document.getElementById("metricRgb");
      const metricSpeed = document.getElementById("metricSpeed");
      const metricSlice = document.getElementById("metricSlice");
      const metricMicro = document.getElementById("metricMicro");

      const barDistortion = document.getElementById("barDistortion");
      const barGlitch = document.getElementById("barGlitch");
      const barRgb = document.getElementById("barRgb");
      const barSpeed = document.getElementById("barSpeed");
      const barSlice = document.getElementById("barSlice");
      const barMicro = document.getElementById("barMicro");

      const clock = new THREE.Clock();
      const renderer = new THREE.WebGLRenderer({
        canvas: webglCanvas,
        antialias: false,
        alpha: false,
        powerPreference: "high-performance",
      });
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      const geometry = new THREE.PlaneGeometry(2, 2);

      const params = {
        intensity: 0.48,
        distortionStrength: 0.33,
        glitchAmount: 0.36,
        rgbShift: 0.2,
        speed: 0.72,
        sliceStrength: 0.24,
      };

      const uniforms = {
        uTexture: { value: null },
        uResolution: { value: new THREE.Vector2(1, 1) },
        uImageResolution: { value: new THREE.Vector2(1, 1) },
        uTime: { value: 0 },
        uIntensity: { value: params.intensity },
        uDistortionStrength: { value: params.distortionStrength },
        uGlitchAmount: { value: params.glitchAmount },
        uRgbShift: { value: params.rgbShift },
        uSpeed: { value: params.speed },
        uSliceStrength: { value: params.sliceStrength },
        uPointer: { value: new THREE.Vector2(0, 0) },
        uPointerVelocity: { value: 0 },
        uMicroGlitch: { value: 0 },
        uBlockSeed: { value: Math.random() * 1000 },
      };

      const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          precision highp float;

          uniform sampler2D uTexture;
          uniform vec2 uResolution;
          uniform vec2 uImageResolution;
          uniform float uTime;
          uniform float uIntensity;
          uniform float uDistortionStrength;
          uniform float uGlitchAmount;
          uniform float uRgbShift;
          uniform float uSpeed;
          uniform float uSliceStrength;
          uniform vec2 uPointer;
          uniform float uPointerVelocity;
          uniform float uMicroGlitch;
          uniform float uBlockSeed;
          varying vec2 vUv;

          float hash11(float p) {
            p = fract(p * 0.1031);
            p *= p + 33.33;
            p *= p + p;
            return fract(p);
          }

          float hash21(vec2 p) {
            vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
          }

          float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(
              mix(hash21(i + vec2(0.0, 0.0)), hash21(i + vec2(1.0, 0.0)), u.x),
              mix(hash21(i + vec2(0.0, 1.0)), hash21(i + vec2(1.0, 1.0)), u.x),
              u.y
            );
          }

          float fbm(vec2 p) {
            float v = 0.0;
            float amp = 0.5;
            for (int i = 0; i < 5; i++) {
              v += noise(p) * amp;
              p = p * 2.03 + vec2(10.7, 7.9);
              amp *= 0.52;
            }
            return v;
          }

          vec2 coverUv(vec2 uv, vec2 screen, vec2 image) {
            float rs = screen.x / max(screen.y, 0.0001);
            float ri = image.x / max(image.y, 0.0001);
            if (rs > ri) {
              float scale = ri / rs;
              uv.y = (uv.y - 0.5) * scale + 0.5;
            } else {
              float scale = rs / ri;
              uv.x = (uv.x - 0.5) * scale + 0.5;
            }
            return uv;
          }

          void main() {
            float t = uTime * (0.35 + uSpeed * 1.65);
            vec2 uv = coverUv(vUv, uResolution, uImageResolution);

            vec2 turbulenceUv = uv * vec2(4.8, 3.9) + vec2(0.0, t * 0.12);
            float f1 = fbm(turbulenceUv);
            float f2 = fbm(turbulenceUv * 2.1 - vec2(t * 0.08, t * 0.16));
            float tremor = (f1 - 0.5) * 0.0042 + (f2 - 0.5) * 0.0025;
            vec2 displacement = vec2(tremor * 1.15, tremor * 0.62) * (0.25 + uDistortionStrength * 0.9);

            vec2 pointerUv = uPointer * 0.5 + 0.5;
            float pointerField = smoothstep(0.56, 0.0, distance(vUv, pointerUv));
            displacement += vec2(f2 - 0.5, f1 - 0.5) * 0.01 * pointerField * (0.45 + uPointerVelocity * 0.8);

            float sliceRows = mix(5.0, 34.0, uSliceStrength);
            float sliceStep = floor(t * 11.0);
            float sliceId = floor(vUv.y * sliceRows + sliceStep);
            float sliceRand = hash11(sliceId + uBlockSeed * 0.73);
            float sliceMask = step(0.95 - uSliceStrength * 0.52, sliceRand) * uGlitchAmount;
            float sliceShift = (sliceRand - 0.5) * (0.016 + uSliceStrength * 0.04) * (0.32 + uMicroGlitch * 0.68);

            vec2 blockGrid = vec2(26.0, 14.0) + vec2(22.0, 10.0) * uGlitchAmount;
            vec2 blockId = floor(vUv * blockGrid + vec2(sliceStep * 0.27));
            float blockRand = hash21(blockId + vec2(uBlockSeed, uBlockSeed * 0.37));
            float blockMask = smoothstep(0.95 - uGlitchAmount * 0.55, 1.0, blockRand) * mix(0.36, 1.0, uMicroGlitch);

            vec2 blockOffset = vec2(
              (hash21(blockId + 17.3) - 0.5) * (0.01 + uGlitchAmount * 0.045),
              (hash21(blockId + 9.1) - 0.5) * 0.0042
            ) * blockMask;

            vec2 signalUv = uv + displacement + blockOffset + vec2(sliceMask * sliceShift, 0.0);
            vec2 radialDir = normalize(vec2(0.001) + (vUv - 0.5));
            float aberr = (0.00055 + uRgbShift * 0.0048) * (0.55 + uIntensity * 0.7);
            vec2 chroma = radialDir * aberr + vec2(blockMask * 0.0018, -blockMask * 0.0009);

            float r = texture2D(uTexture, signalUv + chroma).r;
            float g = texture2D(uTexture, signalUv).g;
            float b = texture2D(uTexture, signalUv - chroma).b;
            vec3 color = vec3(r, g, b);

            vec2 jumpUv = signalUv + vec2((hash21(blockId + 61.7) - 0.5) * 0.03 * blockMask, 0.0);
            vec3 jumpColor = texture2D(uTexture, jumpUv).rgb;
            color = mix(color, jumpColor, blockMask * (0.12 + uGlitchAmount * 0.44));

            float quant = mix(240.0, 72.0, blockMask * (0.4 + uGlitchAmount * 0.6));
            color = floor(color * quant) / quant;

            float scan = sin((vUv.y * uResolution.y) * 1.28 + t * 14.0) * 0.5 + 0.5;
            float scanline = (scan - 0.5) * 0.026 * (0.26 + uIntensity * 0.74);
            float grain = (hash21(gl_FragCoord.xy + t * 120.0) - 0.5) * 0.045;
            color += vec3(scanline);
            color += vec3(grain * 0.16);

            vec3 coldTint = vec3(0.93, 0.985, 1.03);
            color *= mix(vec3(1.0), coldTint, 0.1 + uIntensity * 0.12);

            float vignette = smoothstep(1.08, 0.18, distance(vUv, vec2(0.5)));
            color *= mix(0.84, 1.0, vignette);
            color = clamp(color, 0.0, 1.0);

            gl_FragColor = vec4(color, 1.0);
          }
        `,
      });

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      const pointerTarget = new THREE.Vector2(0, 0);
      const pointerCurrent = new THREE.Vector2(0, 0);
      const pointerPrev = new THREE.Vector2(0, 0);

      let microGlitchFrames = 0;
      let microGlitchCooldown = 14;
      let microGlitchValue = 0;
      let microBurstCount = 0;

      const networkCtx = networkCanvas.getContext("2d");
      let networkNodes = [];

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function fitRenderer() {
        const isMobileLike = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent) || window.innerWidth < 900;
        const dprCap = isMobileLike ? 1.35 : 1.85;
        const dpr = Math.min(window.devicePixelRatio || 1, dprCap);
        renderer.setPixelRatio(dpr);
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
      }

      function fitNetworkCanvas() {
        const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
        networkCanvas.width = Math.max(1, Math.floor(window.innerWidth * dpr));
        networkCanvas.height = Math.max(1, Math.floor(window.innerHeight * dpr));
        networkCanvas.style.width = `${window.innerWidth}px`;
        networkCanvas.style.height = `${window.innerHeight}px`;
        networkCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        buildNetworkNodes();
      }

      function buildNetworkNodes() {
        const area = window.innerWidth * window.innerHeight;
        const count = Math.round(clamp(area / 38000, 34, 74));
        networkNodes = Array.from({ length: count }, () => ({
          x: Math.random() * window.innerWidth,
          y: Math.random() * window.innerHeight,
          vx: (Math.random() - 0.5) * 0.16,
          vy: (Math.random() - 0.5) * 0.16,
        }));
      }

      function drawNetworkBackground(delta) {
        const w = window.innerWidth;
        const h = window.innerHeight;
        networkCtx.clearRect(0, 0, w, h);

        const edgeAlpha = lerp(0.1, 0.25, params.intensity);
        const dotAlpha = lerp(0.28, 0.48, params.intensity);
        const lineThreshold = lerp(82, 148, params.intensity);
        const pointerRadius = 160;
        const px = ((pointerCurrent.x + 1) * 0.5) * w;
        const py = ((-pointerCurrent.y + 1) * 0.5) * h;

        for (let i = 0; i < networkNodes.length; i += 1) {
          const node = networkNodes[i];
          node.x += node.vx * (delta * 60);
          node.y += node.vy * (delta * 60);

          if (node.x < -10) node.x = w + 10;
          if (node.x > w + 10) node.x = -10;
          if (node.y < -10) node.y = h + 10;
          if (node.y > h + 10) node.y = -10;

          const dx = node.x - px;
          const dy = node.y - py;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < pointerRadius) {
            const pull = (1 - d / pointerRadius) * 0.7;
            node.x += (-dx / (d + 0.001)) * pull;
            node.y += (-dy / (d + 0.001)) * pull;
          }
        }

        for (let i = 0; i < networkNodes.length; i += 1) {
          const a = networkNodes[i];
          for (let j = i + 1; j < networkNodes.length; j += 1) {
            const b = networkNodes[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > lineThreshold) continue;

            const alpha = (1 - dist / lineThreshold) * edgeAlpha;
            networkCtx.strokeStyle = `rgba(147, 193, 255, ${alpha.toFixed(4)})`;
            networkCtx.lineWidth = 0.66;
            networkCtx.beginPath();
            networkCtx.moveTo(a.x, a.y);
            networkCtx.lineTo(b.x, b.y);
            networkCtx.stroke();
          }
        }

        for (let i = 0; i < networkNodes.length; i += 1) {
          const p = networkNodes[i];
          networkCtx.fillStyle = `rgba(182, 212, 255, ${dotAlpha})`;
          networkCtx.beginPath();
          networkCtx.arc(p.x, p.y, 1.08, 0, Math.PI * 2);
          networkCtx.fill();
        }

        const rect = focusFrame.getBoundingClientRect();
        networkCtx.strokeStyle = "rgba(156, 197, 255, 0.16)";
        networkCtx.lineWidth = 1;
        networkCtx.strokeRect(rect.left, rect.top, rect.width, rect.height);
      }

      function updateMicroGlitch() {
        if (microGlitchFrames > 0) {
          microGlitchFrames -= 1;
          microGlitchValue = 1;
          return;
        }

        microGlitchValue = lerp(microGlitchValue, 0, 0.16);
        microGlitchCooldown -= 1;
        const triggerChance = (0.007 + params.glitchAmount * 0.042) * (0.7 + params.intensity * 0.45);
        if (microGlitchCooldown <= 0 && Math.random() < triggerChance) {
          microGlitchFrames = 1 + Math.floor(Math.random() * 3);
          microGlitchCooldown = 14 + Math.floor(Math.random() * 58);
          uniforms.uBlockSeed.value = Math.random() * 1000;
          microBurstCount += 1;
        }
      }

      function updateProbeUI() {
        metricDistortion.textContent = params.distortionStrength.toFixed(2);
        metricGlitch.textContent = params.glitchAmount.toFixed(2);
        metricRgb.textContent = params.rgbShift.toFixed(2);
        metricSpeed.textContent = params.speed.toFixed(2);
        metricSlice.textContent = params.sliceStrength.toFixed(2);
        metricMicro.textContent = `${microBurstCount}`;

        barDistortion.style.width = `${Math.round(params.distortionStrength * 100)}%`;
        barGlitch.style.width = `${Math.round(params.glitchAmount * 100)}%`;
        barRgb.style.width = `${Math.round(params.rgbShift * 100)}%`;
        barSpeed.style.width = `${Math.round((params.speed / 2) * 100)}%`;
        barSlice.style.width = `${Math.round(params.sliceStrength * 100)}%`;
        barMicro.style.width = `${Math.round(clamp(microGlitchValue * 100, 0, 100))}%`;

        statusText.textContent = microGlitchValue > 0.55 ? "Micro Burst Detected" : "Stable Signal";
      }

      function onPointerMove(event) {
        const nx = (event.clientX / window.innerWidth) * 2 - 1;
        const ny = -((event.clientY / window.innerHeight) * 2 - 1);
        pointerTarget.set(clamp(nx, -1, 1), clamp(ny, -1, 1));
      }

      function onPointerLeave() {
        pointerTarget.set(0, 0);
      }

      function loadTexture(url) {
        const loader = new THREE.TextureLoader();
        return new Promise((resolve, reject) => {
          loader.load(
            url,
            (texture) => resolve(texture),
            undefined,
            (error) => reject(error)
          );
        });
      }

      async function initTexture() {
        let texture = null;
        try {
          texture = await loadTexture(IMAGE_URL);
        } catch (_error) {
          try {
            texture = await loadTexture(FALLBACK_URL);
          } catch (_error2) {
            warningBox.style.display = "block";
            return;
          }
        }

        texture.colorSpace = THREE.SRGBColorSpace;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.generateMipmaps = true;
        uniforms.uTexture.value = texture;
        uniforms.uImageResolution.value.set(texture.image.width || 1, texture.image.height || 1);
      }

      function animate() {
        const delta = clamp(clock.getDelta(), 0.001, 0.05);
        uniforms.uTime.value += delta;

        pointerPrev.copy(pointerCurrent);
        pointerCurrent.lerp(pointerTarget, 0.08);
        const pointerDelta = pointerCurrent.distanceTo(pointerPrev);

        uniforms.uPointer.value.copy(pointerCurrent);
        uniforms.uPointerVelocity.value = clamp(pointerDelta * 42, 0, 1);

        updateMicroGlitch();

        uniforms.uIntensity.value = params.intensity;
        uniforms.uDistortionStrength.value = params.distortionStrength;
        uniforms.uGlitchAmount.value = params.glitchAmount;
        uniforms.uRgbShift.value = params.rgbShift;
        uniforms.uSpeed.value = params.speed;
        uniforms.uSliceStrength.value = params.sliceStrength;
        uniforms.uMicroGlitch.value = microGlitchValue;

        drawNetworkBackground(delta);
        updateProbeUI();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      function initGUI() {
        const gui = new GUI({ title: "Signal Controls", width: 286 });
        gui.add(params, "intensity", 0, 1, 0.001);
        gui.add(params, "distortionStrength", 0, 1, 0.001);
        gui.add(params, "glitchAmount", 0, 1, 0.001);
        gui.add(params, "rgbShift", 0, 1, 0.001);
        gui.add(params, "speed", 0, 2, 0.001);
        gui.add(params, "sliceStrength", 0, 1, 0.001);
        if (window.innerWidth < 920) {
          gui.close();
        }
      }

      function initEvents() {
        window.addEventListener("resize", () => {
          fitRenderer();
          fitNetworkCanvas();
        });

        window.addEventListener("pointermove", onPointerMove, { passive: true });
        window.addEventListener("pointerleave", onPointerLeave);
        window.addEventListener(
          "touchmove",
          (event) => {
            const touch = event.touches?.[0];
            if (!touch) return;
            onPointerMove({ clientX: touch.clientX, clientY: touch.clientY });
          },
          { passive: true }
        );
      }

      async function bootstrap() {
        fitRenderer();
        fitNetworkCanvas();
        initEvents();
        initGUI();
        await initTexture();
        animate();
      }

      bootstrap();
    </script>
  </body>
</html>
